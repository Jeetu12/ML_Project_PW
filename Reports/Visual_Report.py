# -*- coding: utf-8 -*-
"""Visual_Report.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Aoh3ufs_0KhAtLalx6dhSE_NMGu1HWUN
"""

#  Live CoinGecko Visual Report of Crypto Liquidity

# STEP 1: Install packages (Google Colab)
!pip install requests pandas matplotlib seaborn fpdf --quiet

# STEP 2: Imports
import requests
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from fpdf import FPDF
import numpy as np

import warnings
warnings.filterwarnings("ignore")

# STEP 3: Fetch live data from CoinGecko
url = "https://api.coingecko.com/api/v3/coins/markets"
params = {
    "vs_currency": "usd",
    "order": "market_cap_desc",
    "per_page": 50,
    "page": 1,
    "sparkline": "false",
    "price_change_percentage": "1h,24h,7d"
}
response = requests.get(url, params=params)
data = response.json()

# STEP 4: Create DataFrame
df = pd.DataFrame(data)[['id', 'symbol', 'current_price', 'market_cap',
                         'total_volume', 'price_change_percentage_1h_in_currency',
                         'price_change_percentage_24h_in_currency',
                         'price_change_percentage_7d_in_currency']]

df.columns = ['coin', 'symbol', 'price', 'mkt_cap', '24h_volume', '1h', '24h', '7d']
df.dropna(inplace=True)

# STEP 5: Feature Engineering
df['liquidity_ratio'] = df['24h_volume'] / df['mkt_cap']
df['volatility'] = df['24h'].abs()

# Save plots
sns.set(style="whitegrid")
heatmap_path = "heatmap.png"
feat_imp_path = "feature_importance.png"
pred_vs_actual_path = "predicted_vs_actual.png"

# Correlation Heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(df[['price', '1h', '24h', '7d', 'mkt_cap', '24h_volume', 'liquidity_ratio', 'volatility']].corr(), annot=True, cmap="coolwarm")
plt.title("Correlation Heatmap")
plt.tight_layout()
plt.savefig(heatmap_path)
plt.close()

# Feature Importance (Mock values)
features = ['price', '1h', '24h', '7d', '24h_volume', 'mkt_cap', 'volatility']
importances = [0.05, 0.15, 0.25, 0.1, 0.2, 0.15, 0.1]
plt.figure(figsize=(8, 5))
sns.barplot(x=importances, y=features, palette="crest")
plt.title("Mock Feature Importance")
plt.tight_layout()
plt.savefig(feat_imp_path)
plt.close()

# Predicted vs Actual (Mock)
y_test = df['liquidity_ratio'].values
y_pred = y_test + np.random.normal(0, 0.005, len(y_test))
plt.figure(figsize=(6, 6))
sns.scatterplot(x=y_test, y=y_pred)
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], '--r')
plt.xlabel("Actual Liquidity Ratio")
plt.ylabel("Predicted Liquidity Ratio")
plt.title("Predicted vs Actual")
plt.tight_layout()
plt.savefig(pred_vs_actual_path)
plt.close()

# STEP 6: PDF Report
pdf = FPDF()
pdf.add_page()
pdf.set_font("Arial", 'B', 16)
pdf.cell(0, 10, "Live Crypto Liquidity Visual Report", ln=True)

pdf.set_font("Arial", '', 12)
pdf.ln(10)
pdf.multi_cell(0, 8, "This report is based on real-time cryptocurrency market data from CoinGecko. It shows liquidity behavior, volatility, and correlation among top coins.")

pdf.ln(8)
pdf.cell(0, 10, "1. Correlation Heatmap", ln=True)
pdf.image(heatmap_path, w=180)

pdf.add_page()
pdf.cell(0, 10, "2. Feature Importance (Mock)", ln=True)
pdf.image(feat_imp_path, w=160)

pdf.ln(10)
pdf.cell(0, 10, "3. Predicted vs Actual (Mock)", ln=True)
pdf.image(pred_vs_actual_path, w=150)

pdf.output("Live_Crypto_Visual_Report.pdf")

# OPTIONAL: Download link in Colab
from google.colab import files
files.download("Live_Crypto_Visual_Report.pdf")

# Notes:

# This uses real market data (top 50 coins).

# Predictions and feature importances are mocked for visualization.

# You can connect this to a trained ML model for true prediction visuals.

# STEP 1: Install libraries
!pip install requests pandas matplotlib seaborn scikit-learn fpdf --quiet

# STEP 2: Import libraries
import requests
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_squared_error
from fpdf import FPDF

# STEP 3: Get live data from CoinGecko
url = "https://api.coingecko.com/api/v3/coins/markets"
params = {
    "vs_currency": "usd",
    "order": "market_cap_desc",
    "per_page": 100,
    "page": 1,
    "sparkline": "false",
    "price_change_percentage": "1h,24h,7d"
}
response = requests.get(url, params=params)
data = response.json()

# STEP 4: Convert to DataFrame
df = pd.DataFrame(data)[['id', 'symbol', 'current_price', 'market_cap', 'total_volume',
                         'price_change_percentage_1h_in_currency',
                         'price_change_percentage_24h_in_currency',
                         'price_change_percentage_7d_in_currency']]

df.columns = ['coin', 'symbol', 'price', 'mkt_cap', '24h_volume', '1h', '24h', '7d']
df.dropna(inplace=True)

# STEP 5: Feature Engineering
df['liquidity_ratio'] = df['24h_volume'] / df['mkt_cap']
df['volatility'] = df['24h'].abs()

features = ['price', '1h', '24h', '7d', '24h_volume', 'mkt_cap', 'volatility']
target = 'liquidity_ratio'

X = df[features]
y = df[target]

# STEP 6: Train ML model
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
model = RandomForestRegressor(random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

r2 = r2_score(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

# STEP 7: Plotting
sns.set(style="whitegrid")

# Heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(df[features + ['liquidity_ratio']].corr(), annot=True, cmap="coolwarm")
plt.title("Correlation Heatmap")
plt.tight_layout()
plt.savefig("heatmap.png")
plt.close()

# Feature Importance
importances = model.feature_importances_
plt.figure(figsize=(8, 5))
sns.barplot(x=importances, y=features, palette="crest")
plt.title("Feature Importance (from Model)")
plt.tight_layout()
plt.savefig("feature_importance.png")
plt.close()

# Predicted vs Actual
plt.figure(figsize=(6, 6))
sns.scatterplot(x=y_test, y=y_pred)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], '--r')
plt.xlabel("Actual Liquidity Ratio")
plt.ylabel("Predicted Liquidity Ratio")
plt.title("Predicted vs Actual")
plt.tight_layout()
plt.savefig("predicted_vs_actual.png")
plt.close()

# STEP 8: Create PDF report
pdf = FPDF()
pdf.add_page()
pdf.set_font("Arial", 'B', 16)
pdf.cell(0, 10, "Live Crypto Liquidity ML Report", ln=True)

pdf.set_font("Arial", '', 12)
pdf.ln(10)
pdf.multi_cell(0, 8, f"""This report uses live cryptocurrency data from CoinGecko to train a Random Forest model that predicts the liquidity ratio based on market metrics.

Model Performance:
- RÂ² Score: {r2:.3f}
- RMSE: {rmse:.4f}
""")

pdf.ln(8)
pdf.cell(0, 10, "1. Correlation Heatmap", ln=True)
pdf.image("heatmap.png", w=180)

pdf.add_page()
pdf.cell(0, 10, "2. Feature Importance", ln=True)
pdf.image("feature_importance.png", w=160)

pdf.ln(10)
pdf.cell(0, 10, "3. Predicted vs Actual", ln=True)
pdf.image("predicted_vs_actual.png", w=150)

pdf.output("Live_Crypto_Model_Report.pdf")

# Optional: Download in Colab
from google.colab import files
files.download("Live_Crypto_Model_Report.pdf")